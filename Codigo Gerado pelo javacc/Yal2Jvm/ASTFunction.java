package Yal2Jvm;

import Yal2Jvm.CodeGeneration.IR.*;
import Yal2Jvm.CodeGeneration.IRFilling.FunctionIRFiller;
import Yal2Jvm.SemanticAnalysis.InitializationVerifier.FunctionInitializationVerifier;
import Yal2Jvm.SemanticAnalysis.STFilling.FunctionSTFiller;

import java.util.HashSet;

/* Generated By:JJTree: Do not edit this line. Yal2Jvm.ASTFunction.java Version 4.3 */
 /* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
/**
 * Function expression generated by JJTree.
 * This node stores the function name.
 * ASTFunction overrides the dump, fillStFirstPass, fillIRSecondPass, verifyInitialization, verifyOperatorSyntax, fillIRFirstPass and fillIRSecondPass methods from the SimpleNode class so it can introduce special behaviors for each. And introduces the new methods verifyInitializationSuper, getReturnVariableID and fillIRFirstPassSuper. 
 */
public class ASTFunction extends SimpleNode
{
    /**
     * Is responsible for filling the symbol table.
     */
    private final FunctionSTFiller functionSTFiller = new FunctionSTFiller(this);
    /**
     * Is responsible for verifying the initialization of variables.
     */
    private final FunctionInitializationVerifier functionInitializationVerifier = new FunctionInitializationVerifier(this);
    /**
     * Is responsible for filling the IR.
     */
    private final FunctionIRFiller functionIRFiller = new FunctionIRFiller(this);
    /**
     * The id/name of the function.
     */
    public String functionId = "";

    /**
     * Constructor of the non-terminal expression 'Function'.
     * @param id ID of the node.
     */
    public ASTFunction(int id)
    {
        super(id);
    }
	/**
	 * Constructor of the non-terminal expression 'Function'.
	 * @param p Scanner object.
	 * @param id ID of the node.
	 */
    public ASTFunction(Scanner p, int id)
    {
        super(p, id);
    }

    public String getFunctionId()
    {
        return functionId;
    }

    /**
     * Displays information about this node. Correctly formats the information for more user-friendly reading on the console.
     * The method is overridden in the derived classes whenever special behaviour is necessary.
     * @param prefix The prefix (one or more spaces) to correctly format the information.
     */
    public void dump(String prefix)
    {
        System.out.println(toString(prefix));
        System.out.println(prefix + "Function ID:" + functionId);
        if (children != null)
        {
            for (int i = 0; i < children.length; ++i)
            {
                SimpleNode n = (SimpleNode) children[i];
                if (n != null)
                {
                    n.dump(prefix + " ");
                }
            }
        }
    }

    /**
     * This method is called recursively to go through the entire AST to fill the symbol table.
     * It is Overridden by this derived classes because special behaviour is needed. That special behaviour is implemented by the function fillStFirstPass on the class FunctionSTFiller.
     * It is placed in the AST because it needs to go through it. The code to perform the actual filling and necessary semantic analysis is placed in different classes, respecting the single responsibility principle.
     * On the first pass, only function definitions are filled in the symbol table. Function bodies will be filled in the second pass.
     * @param st An Object that represents the symbol table to be filled.
     */
    public void fillStFirstPass(ST st)
    {
        functionSTFiller.fillStFirstPass(st);
    }

    /**
     * This method is called recursively to go through the entire AST to fill the symbol table.
     * It is Overridden by this derived classes because special behaviour is needed. That special behaviour is implemented by the function because there is no need for specific class since it is only two lines of code.
     * It is placed in the AST because it needs to go through it. The code to perform the actual filling and necessary semantic analysis is placed in different classes, respecting the single responsibility principle.
     * On the second pass, function bodies are filled in the symbol table.
     * @param st An Object that represents the symbol table to be filled.
     */
    public void fillStSecondPass(ST st)
    {
        FunctionST thisFunctionST = ((ModuleST) st).getFunctionST(functionId);
        super.fillStSecondPass(thisFunctionST);
    }

    /**
     * This method is called recursively to go through the entire AST verify the variable initialization.
     * It is Overridden by this derived classes because special behaviour is needed. That special behaviour is implemented by the function verifyInitialization on the class FunctionInitializationVerifier.
     * It is placed in the AST because it needs to go through it. The code to perform the actual verification of the variable initialization is placed in different classes, respecting the single responsibility principle.
     * @param initializedVariables A set containing the currently initialized variables (in the current node of the AST). As new variables get initialized, they are added to the set.
     * @param st An Object that represents the already filled symbol table.
     * @return The set of initialized variables after the current AST node (new variables could eventually have been added to the set it received as parameter if they actually for initialized in the current AST node).
     */
    public HashSet verifyInitialization(HashSet<String> initializedVariables, ST st)
    {

        return functionInitializationVerifier.verifyInitialization(initializedVariables, st);
    }

    /**
     * This method mirrors the super class' method verifyInitialization.
     * @param initializedVariables A set containing the currently initialized variables (in the current node of the AST). As new variables get initialized, they are added to the set.
     * @param st An Object that represents the already filled symbol table.
     * @return The set of initialized variables after the current AST node (new variables could eventually have been added to the set it received as parameter if they actually for initialized in the current AST node).
     */
    public HashSet verifyInitializationSuper(HashSet<String> initializedVariables, ST st)
    {
        return super.verifyInitialization(initializedVariables, st);
    }

    /**
     * Returns the ID (a String) of the variable that represents the return of this function.
     * @return A String representing the ID of the variable that represents the return of this function. 
     */
    public String getReturnVariableID()
    {
        String returnVarID;
        if (children[0] instanceof ASTArrayElement)
            returnVarID = ((ASTArrayElement) children[0]).arrayID;
        else if (children[0] instanceof ASTScalarElement)
            returnVarID = ((ASTScalarElement) children[0]).scalarID;
        else
            returnVarID = null;

        return returnVarID;
    }

    /**
     * This method is called recursively to go through the entire AST verify the operator syntax.
     * It is Overridden by this derived classes because special behaviour is needed. That special behaviour is implemented by this function since there's no need ot specialized class because it is only two lines of code.
     * It is placed in the AST because it needs to go through it. The code to perform the actual verification of the operator syntax is placed in different classes, respecting the single responsibility principle.
     * @param st An Object that represents the already filled symbol table.
     * @param operatorHasToBeInt A boolean indicating weather the next operator found has to be an int or not.
     */
    public void verifyOperatorSyntax(ST st, boolean operatorHasToBeInt)
    {
        FunctionST thisFunctionST = ((ModuleST) st).getFunctionST(functionId);
        super.verifyOperatorSyntax(thisFunctionST, operatorHasToBeInt);
    }

    /**
     * This method is called recursively to go through the entire AST to fill the intermediate representation (IR).
     * It is Overridden by this derived classes because special behaviour is needed. That special behaviour is implemented by the function fillIRSecondPass on the class FunctionIRFiller.
     * It is placed in the AST because it needs to go through it. The code to perform the actual filling is placed in different classes, respecting the single responsibility principle.
     * On the first pass, only function definitions are filled in the intermediate representation. Function bodies will be filled in the second pass.
     * @param st An Object that represents the already filled symbol table.
     * @param irContainer A class representing the intermediate representation to be filled.
     */
    public void fillIRFirstPass(ST st, IRContainer irContainer)
    {
        functionIRFiller.fillIRFirstPass(st, irContainer);
    }

    /**
     * This method mirrors the super class' method fillIRFirstPass.
     * @param st An Object that represents the already filled symbol table.
     * @param irContainer A class representing the intermediate representation to be filled. 
     */
    public void fillIRFirstPassSuper(ST st, IRContainer irContainer)
    {
        super.fillIRFirstPass(st, irContainer);
    }

    /**
     * This method is called recursively to go through the entire AST to fill the intermediate representation (IR).
     * It is Overridden by this derived classes because special behaviour is needed. That special behaviour is implemented by the function fillIRSecondPass on the class FunctionIRFiller.
     * It is placed in the AST because it needs to go through it. The code to perform the actual filling is placed in different classes, respecting the single responsibility principle.
     * On the first pass, only function definitions are filled in the intermediate representation. Function bodies will be filled in the second pass.
     * @param st An Object that represents the already filled symbol table.
     * @param irContainer A class representing the intermediate representation to be filled.
     * @param currentBlock A class representing the current block on the IR of this AST node. This is used to perform branching on certain conditions.
     */
    public void fillIRSecondPass(ST st, IRContainer irContainer, BasicBlock currentBlock)
    {
        functionIRFiller.fillIRSecondPass(st, irContainer, currentBlock);
    }
}
/*
 * JavaCC - OriginalChecksum=8f138bc058f508a005084224e1f23dbc (do not edit this
 * line)
 */
