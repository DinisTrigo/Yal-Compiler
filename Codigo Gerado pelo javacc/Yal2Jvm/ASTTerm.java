package Yal2Jvm;

import Yal2Jvm.SemanticAnalysis.InitializationVerifier.TermInitializationVerifier;
import Yal2Jvm.SemanticAnalysis.OperatorSyntaxVerification.TermOperatorSyntaxVerifier;

import java.util.HashSet;

/* Generated By:JJTree: Do not edit this line. Yal2Jvm.ASTTerm.java Version 4.3 */
 /* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
/**
 * Term expression generated by JJTree.
 * This node stores the sign for a value, and possibly stores the value of an integer. 
 * ASTTerm overrides the dump, verifyInitialization and verifyOperatorSyntax methods from the SimpleNode class so it can introduce special behaviors for each. And introduces the new methods returnIsArray and getOperand. 
 */
public class ASTTerm extends SimpleNode
{
    /**
     * Is responsible for verifying the syntax of the term operator.
     */
    private final TermOperatorSyntaxVerifier termOperatorSyntaxVerifier = new TermOperatorSyntaxVerifier(this);
    /**
     * The sign of the function, literal or variable that represents the term. Can be null if the term has no sign.
     */
    public String addSub_Op;
    /**
     * The value of the literal in case the term is represented by a literal. Otherwise, this shall be null.
     */
    public Integer termInt;
    /**
     * Constructor of the non-terminal expression 'Term'.
     * @param id ID of the node.
     */
    public ASTTerm(int id)
    {
        super(id);
    }
    /**
     * Constructor of the non-terminal expression 'Term'.
     * @param p Scanner object.
     * @param id ID of the node.
     */
    public ASTTerm(Scanner p, int id)
    {
        super(p, id);
    }

    /**
     * Displays information about this node. Correctly formats the information for more user-friendly reading on the console.
     * The method is overridden in the derived classes whenever special behaviour is necessary.
     * @param prefix The prefix (one or more spaces) to correctly format the information.
     */
    public void dump(String prefix)
    {
        System.out.println(toString(prefix));
        if (addSub_Op != null)
            System.out.println(prefix + " Term sign: " + addSub_Op);
        if (termInt != null)
            System.out.println(prefix + " Integer value: " + termInt);
        if (children != null)
        {
            for (int i = 0; i < children.length; ++i)
            {
                SimpleNode n = (SimpleNode) children[i];
                if (n != null)
                {
                    n.dump(prefix + " ");
                }
            }
        }
    }

    /**
     * This function returns a Boolean variable indicating weather the return of this Term is an array or not.
     * @param st The current symbol table to perform the verify the sub-variables or even sub-terms used are arrays or not.
     * @return A Boolean value indicating weather the return of this Term is an array or not.
     * @throws ExternalModuleCall Throws when the ASTCall child node has field innerCalledID not null, because it can't be a method from a module.
     */
    public Boolean returnIsArray(ST st) throws ExternalModuleCall
    {
        if (termInt != null) //the integer is not null, so the content is stored in there, which means it is an int and not an array
            return false;
        if (children[0] instanceof ASTArrayAccess) //an array access always returns an int
            return false;
        else if (children[0] instanceof ASTScalarAccess) //a scalar access may return either an array or int
            return ((ASTScalarAccess) children[0]).returnIsArray(st);

        return ((ASTCall) children[0]).returnIsArray(st);
    }

    /**
     * This method is called recursively to go through the entire AST verify the variable initialization.
     * It is Overridden by this derived classes because special behaviour is needed. That special behaviour is implemented by the function verifyInitialization on the class TermInitializationVerifier.
     * It is placed in the AST because it needs to go through it. The code to perform the actual verification of the variable initialization is placed in different classes, respecting the single responsibility principle.
     * @param initializedVariables A set containing the currently initialized variables (in the current node of the AST). As new variables get initialized, they are added to the set.
     * @param st An Object that represents the already filled symbol table.
     * @return The set of initialized variables after the current AST node (new variables could eventually have been added to the set it received as parameter if they actually for initialized in the current AST node).
     */
    public HashSet verifyInitialization(HashSet<String> initializedVariables, ST st)
    {
        return TermInitializationVerifier.verifyInitialization(children, termInt, initializedVariables, st);
    }

    /**
     * This method is called recursively to go through the entire AST verify the operator syntax.
     * It is Overridden by this derived classes because special behaviour is needed. That special behaviour is implemented by the function verifyInitialization on the class TermOperatorSyntaxVerifier.
     * It is placed in the AST because it needs to go through it. The code to perform the actual verification of the operator syntax is placed in different classes, respecting the single responsibility principle.
     * @param st An Object that represents the already filled symbol table.
     * @param operatorHasToBeInt A boolean indicating weather the next operator found has to be an int or not.
     */
    public void verifyOperatorSyntax(ST st, boolean operatorHasToBeInt)
    {
        termOperatorSyntaxVerifier.verifyOperatorSyntax(st, operatorHasToBeInt);
    }

    /**
     * Getter for the addSub_Op attrib.
     * @return A String representing the addSub_Op attrib.
     */
    public String getAddSub_Op()
    {
        return addSub_Op;
    }

    /**
     * Getter for the termInt attrib.
     * @return A Integer representing the termInt attrib.
     */
    public Integer getTermInt()
    {
        return termInt;
    }
}
/*
 * JavaCC - OriginalChecksum=a182734dd4c7fd648271b8db93aaf8b0 (do not edit this
 * line)
 */
