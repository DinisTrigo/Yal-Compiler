/* Scanner.java */
/* Generated By:JJTree&JavaCC: Do not edit this line. Scanner.java */
package Yal2Jvm;

import java.io.*;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.HashSet;

import Yal2Jvm.CodeGeneration.IR.ControlFlowGraph;
import Yal2Jvm.CodeGeneration.RegisterAllocation.GlobalRegisterAllocator;
import Yal2Jvm.Utils.globals;

/**
 * Main class that starts the whole compiler program.
 */
public class Scanner/*@bgen(jjtree)*/ implements ScannerTreeConstants, ScannerConstants
{/*@bgen(jjtree)*/
    protected static JJTScannerState jjtree = new JJTScannerState();
    private static boolean parse_error = false;

    /**
     * Main function that receives and parses the command line arguments and creates a new instance of this class to perform the compiling of the program.
     * @param args An array of String containing the command line arguments given to the program. Usage is correctly described when the program is invoked.
     * @throws ParseException Exception throw when the parser encounters a problem.
     */
    public static void main(String[] args) throws ParseException
    {
        if (args.length == 0)
        {
            System.out.println("Insufficient number of arguments for Yal2Jvm compiler. Please supply at least one argument.");
            displayUsage();
            return;
        }

        int indexOfO = Arrays.asList(args).indexOf("-o");
        boolean optimizationsOn = indexOfO != -1;
        globals.constant_folding = optimizationsOn;
        globals.constant_propagation = optimizationsOn;

        int indexOfR = indexThatMatchesRegex(args, "-r=([^\\s]+)");
        if (indexOfR != -1)
        {
            String optionR = args[indexOfR];
            String numberOfRegistersStr = optionR.substring(3, optionR.length());
            Integer numberOfRegisters = Integer.parseInt(numberOfRegistersStr);
            numberOfRegisters = validateNumberOfRegisters(numberOfRegisters);
            if (numberOfRegisters == null)
                return;

            globals.numberOfAvailableRegisters = numberOfRegisters;
        }
        else
            globals.numberOfAvailableRegisters = 255;

        Integer fileNameIndex = getFileNameIndex(indexOfO, indexOfR);
        if (fileNameIndex >= args.length)
        {
            System.out.println("You must supply the file name containing the yal code to be compiled as command line argument to the program.");
            displayUsage();
            return;
        }

        String file_name = args[fileNameIndex];
        InputStream file = null;
        try
        {
            file = new FileInputStream(file_name);
        } catch (FileNotFoundException e)
        {
            System.out.println("The file corresponding to the filename specified as argument could be found. Please verify the filename given.");
            displayUsage();
            return;
        }
        Scanner s = new Scanner(file);
        s.compileFile();
    }

    /**
     * Axiliary function for parsing the arguments. Ir returns the index of the array received as first parameter that matches the regular expression received as second parameter.
     * @param array An array to search for the regular expression match.
     * @param regex The regular expression to match on the given array.
     * @return The index of the array which matches the regular expression received as parameter. Returns -1 if no index matches.
     */
    private static int indexThatMatchesRegex(String[] array, String regex)
    {
        for (int i = 0; i < array.length; i++)
        {
            if (array[i].matches(regex))
                return i;
        }

        return -1;
    }

    /**
     * Returns the index of the filename by exclusion. It assumes the file is always the lowest index possible, not considering the indexes that are already taken by the -o and -r argument options.
     * This is used to provide the user with a lot of usage tolerance, allowing the arguments can be specified in any order without any problem.
     * @param indexOfO An int value representing the index of the -o option.
     * @param indexOfR An int value representing the index of the -r option.
     * @return An int value representing the index of the string representing the filename.
     */
    static Integer getFileNameIndex(int indexOfO, int indexOfR)
    {
        HashSet<Integer> optionalIndexes = new HashSet<>();
        optionalIndexes.add(indexOfO);
        optionalIndexes.add(indexOfR);

        HashSet<Integer> possibleIndexes = new HashSet<>();
        possibleIndexes.add(0);
        possibleIndexes.add(1);
        possibleIndexes.add(2);
        possibleIndexes.removeAll(optionalIndexes); //get the index of the input file by exclusion, allowing any possible order of arguments

        return Collections.min(possibleIndexes);
    }

    /**
     * This function validates the argument that represents the available number of registers. Ensure that the number is between 0 and 255.
     * @param numberOfRegisters The number of registers provided by the user, to be validated by this function.
     * @return An Integer value representing the number of registers fixed, if it needs to be fixed. This is for the case the user provides 0, it will be adapted to 255.
     */
    static Integer validateNumberOfRegisters(Integer numberOfRegisters)
    {
        if (numberOfRegisters > 255)
        {
            System.out.println("Number of registers to use specified is too high. Please specify a number between 0 and 255.");
            displayUsage();
            return null;
        }
        else if (numberOfRegisters < 0)
        {
            System.out.println("Number of registers to use cannot be less than 0. Please specify a valid number");
            displayUsage();
            return null;
        }
        else if (numberOfRegisters == 0)
            numberOfRegisters = 255;
        return numberOfRegisters;
    }

    /**
     * Displays usage information to run the program.
     */
    private static void displayUsage()
    {
        System.out.println("Usage: java yal2jvm [-r=<num>] [-o] <input_file.yal>");
        System.out.println("or");
        System.out.println("java –jar yal2jvm.jar [-r=<num>] [-o] <input_file.yal>");
        System.out.println("Where: <input_file.yal> is the yal module we would like to compile.");
        System.out.println("The “–r” option tells the compiler to use only the first <num> local variables of the JVM when assigning the local variables used in each yal function to the local JVM variables. Without the “–r” option (similar to –r=0), the compiler will use the available JVM local variables to store the local variables used in each yal function.");
        System.out.println("num is a number between 0 and 255 that specifies how much registers the compiler should use. 0 will use the maximum number of registers: 255");
        System.out.println("With the “–o” option, the compiler will perform a set of code optimizations");
    }

    /**
     * This function performs all necessary actions to compile a file. Created the necessary classes that implement the needed functionalities and calls its methods, causing the whole compiling process to be executed.
     * @throws ParseException Exception throw when the parser encounters a problem.
     */
    void compileFile() throws ParseException
    {
        SimpleNode root = Module();
        if (!parse_error)
        {
            root.dump("");
            ModuleST moduleST = new ModuleST();
            root.fillStFirstPass(moduleST);
            root.fillStSecondPass(moduleST);
            HashSet<String> map = new HashSet<String>();
            root.verifyInitialization(map, moduleST);
            root.verifyOperatorSyntax(moduleST, false);
            if (moduleST.codeHasSemanticErrors())
            {
                System.out.println("Compilation failed with " + moduleST.getNumberOfSemanticErrors() + " semantic errors. Errors' descriptions shown above.");
                return;
            }
            root.fillIRFirstPass(moduleST, null);
            ControlFlowGraph cfg = ((ASTModule) root).cfg;
            root.fillIRSecondPass(moduleST, cfg, null);
            if (moduleST.codeHasSemanticErrors())
            {
                System.out.println("Compilation failed with " + moduleST.getNumberOfSemanticErrors() + " semantic errors. Errors' descriptions shown above.");
                return;
            }
            GlobalRegisterAllocator registerAllocator = new GlobalRegisterAllocator(cfg, globals.numberOfAvailableRegisters);
            if (!registerAllocator.performRegisterAllocation())
                return;
            String instructions = cfg.getInstructions();
            writeJVMCodeToFile(((ASTModule) root).moduleName, instructions);
            System.out.println("The program has compiled has successfully. Assembly code saved to file.");
        }
    }

    /**
     * Writes the generated JVM code to a file. The code to be written is received as parameter.
     * @param moduleName A String representing the name of the module. This is used to set the name of the file to which the assembly code will be written to.
     * @param instructions A String containing the JVM instructions to be written to the file.
     */
    private static void writeJVMCodeToFile(String moduleName, String instructions)
    {
        BufferedWriter out = null;
        try
        {
            out = new BufferedWriter(new FileWriter(moduleName + ".j"));
            out.write(instructions);
        } catch (IOException e)
        {
            System.out.println("Can't write file with compiled jvm code.");
        } finally
        {
            try
            {
                out.close();
            } catch (IOException e)
            {
                e.printStackTrace();
            }
        }
    }


    static void jjtreeOpenNodeScope(Node n)
    {
        ((SimpleNode) n).setLine(getToken(1).beginLine);
    }

    static void jjtreeCloseNodeScope(Node n)
    {

    }

    static final public SimpleNode Module() throws ParseException
    {/*@bgen(jjtree) Module */
        ASTModule jjtn000 = new ASTModule(JJTMODULE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        Token moduleName;
        try
        {
            try
            {
                jj_consume_token(MODULE);
                moduleName = jj_consume_token(ID);
                jj_consume_token(LCHAVETA);
                jjtn000.moduleName = moduleName.image;
                label_1:
                while (true)
                {
                    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                    {
                        case ID:
                        {
                            ;
                            break;
                        }
                        default:
                            jj_la1[0] = jj_gen;
                            break label_1;
                    }
                    Declaration();
                }
                label_2:
                while (true)
                {
                    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                    {
                        case FUNCTION:
                        {
                            ;
                            break;
                        }
                        default:
                            jj_la1[1] = jj_gen;
                            break label_2;
                    }
                    Function();
                }
                jj_consume_token(RCHAVETA);
            } catch (ParseException e)
            {
                System.out.println("Module Err:" + e.toString());
                parse_error = true;
            }
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            if (jjtree.nodeCreated())
            {
                jjtreeCloseNodeScope(jjtn000);
            }
            {
                if ("" != null) return jjtn000;
            }
        } catch (Throwable jjte000)
        {
            if (jjtc000)
            {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else
            {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException)
            {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException)
            {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
        throw new Error("Missing return statement in function");
    }

    static final public void Declaration() throws ParseException
    {/*@bgen(jjtree) Declaration */
        ASTDeclaration jjtn000 = new ASTDeclaration(JJTDECLARATION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        Token t1;
        Token op;
        try
        {
            if (jj_2_1(2))
            {
                ArrayElement();
            } else
            {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case ID:
                    {
                        ScalarElement();
                        break;
                    }
                    default:
                        jj_la1[2] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            }
            try
            {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case ASSIGN:
                    {
                        jj_consume_token(ASSIGN);
                        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                        {
                            case 31:
                            {
                                jj_consume_token(31);
                                ArraySize();
                                jj_consume_token(32);
                                break;
                            }
                            case ADDSUB_OP:
                            case INTEGER:
                            {
                                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                                {
                                    case ADDSUB_OP:
                                    {
                                        op = jj_consume_token(ADDSUB_OP);
                                        jjtn000.addSubOp = op.image;
                                        break;
                                    }
                                    default:
                                        jj_la1[3] = jj_gen;
                                        ;
                                }
                                t1 = jj_consume_token(INTEGER);
                                jjtn000.assignValue = Integer.parseInt(t1.image);
                                break;
                            }
                            default:
                                jj_la1[4] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                        break;
                    }
                    default:
                        jj_la1[5] = jj_gen;
                        ;
                }
                jj_consume_token(PVIRG);
            } catch (ParseException e)
            {
                System.out.println("Declaration Err on right hand side of equal sign:" + e.toString());
                parse_error = true;
                Token t;
                do
                {
                    t = getNextToken();
                }
                while (t.kind != PVIRG);
            }
        } catch (Throwable jjte000)
        {
            if (jjtc000)
            {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else
            {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException)
            {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException)
            {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void Function() throws ParseException
    {/*@bgen(jjtree) Function */
        ASTFunction jjtn000 = new ASTFunction(JJTFUNCTION);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        Token funcID;
        try
        {
            try
            {
                jj_consume_token(FUNCTION);
                if (jj_2_3(2))
                {
                    if (jj_2_2(2))
                    {
                        ArrayElement();
                    } else
                    {
                        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                        {
                            case ID:
                            {
                                ScalarElement();
                                break;
                            }
                            default:
                                jj_la1[6] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                    }
                    jj_consume_token(ASSIGN);
                    funcID = jj_consume_token(ID);
                    jjtn000.functionId = funcID.image;
                } else
                {
                    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                    {
                        case ID:
                        {
                            funcID = jj_consume_token(ID);
                            jjtn000.functionId = funcID.image;
                            break;
                        }
                        default:
                            jj_la1[7] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                }
            } catch (ParseException e)
            {
                System.out.println("Function Err:" + e.toString());
                parse_error = true;
                Token t;
                t = getToken(1);
                while (t.kind != LPAR)
                {
                    getNextToken();
                    t = getToken(1);
                }
            }
            try
            {
                jj_consume_token(LPAR);
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case ID:
                    {
                        Varlist();
                        break;
                    }
                    default:
                        jj_la1[8] = jj_gen;
                        ;
                }
                jj_consume_token(RPAR);
            } catch (ParseException e)
            {
                System.out.println("Function Err:" + e.toString());
                parse_error = true;
                Token t;
                do
                {
                    t = getNextToken();
                }
                while (t.kind != RPAR);
            }
            try
            {
                jj_consume_token(LCHAVETA);
                Stmtlst();
                jj_consume_token(RCHAVETA);
            } catch (ParseException e)
            {
                System.out.println("Function Err:" + e.toString());
                parse_error = true;
                Token t;
                do
                {
                    t = getNextToken();
                }
                while (t.kind != RCHAVETA);
            }
        } catch (Throwable jjte000)
        {
            if (jjtc000)
            {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else
            {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException)
            {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException)
            {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void Varlist() throws ParseException
    {/*@bgen(jjtree) Varlist */
        ASTVarlist jjtn000 = new ASTVarlist(JJTVARLIST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        try
        {
            if (jj_2_4(2))
            {
                ArrayElement();
            } else
            {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case ID:
                    {
                        ScalarElement();
                        break;
                    }
                    default:
                        jj_la1[9] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            }
            label_3:
            while (true)
            {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case VIRG:
                    {
                        ;
                        break;
                    }
                    default:
                        jj_la1[10] = jj_gen;
                        break label_3;
                }
                jj_consume_token(VIRG);
                if (jj_2_5(2))
                {
                    ArrayElement();
                } else
                {
                    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                    {
                        case ID:
                        {
                            ScalarElement();
                            break;
                        }
                        default:
                            jj_la1[11] = jj_gen;
                            jj_consume_token(-1);
                            throw new ParseException();
                    }
                }
            }
        } catch (Throwable jjte000)
        {
            if (jjtc000)
            {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else
            {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException)
            {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException)
            {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void ArrayElement() throws ParseException
    {/*@bgen(jjtree) ArrayElement */
        ASTArrayElement jjtn000 = new ASTArrayElement(JJTARRAYELEMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        Token arrayID;
        try
        {
            try
            {
                arrayID = jj_consume_token(ID);
                jj_consume_token(31);
                jj_consume_token(32);
                jjtn000.arrayID = arrayID.image;
            } catch (ParseException e)
            {
                System.out.println("ArrayElement Err:" + e.toString());
                parse_error = true;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void ScalarElement() throws ParseException
    {/*@bgen(jjtree) ScalarElement */
        ASTScalarElement jjtn000 = new ASTScalarElement(JJTSCALARELEMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        Token scalarID;
        try
        {
            try
            {
                scalarID = jj_consume_token(ID);
                jjtn000.scalarID = scalarID.image;
            } catch (ParseException e)
            {
                System.out.println("ScalarElement Err:" + e.toString());
                Scanner.parse_error = true;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void Stmtlst() throws ParseException
    {/*@bgen(jjtree) Stmtlst */
        ASTStmtlst jjtn000 = new ASTStmtlst(JJTSTMTLST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        try
        {
            try
            {
                label_4:
                while (true)
                {
                    if (getToken(1).kind != RCHAVETA)
                    {
                        ;
                    } else
                    {
                        break label_4;
                    }
                    Stmt();
                }
            } catch (ParseException e)
            {
                System.out.println("Stmtlst Err:" + e.toString());
                Scanner.parse_error = true;
                Token t;
                do
                {
                    t = getNextToken();
                }
                while (t.kind != PVIRG);
            }
        } catch (Throwable jjte000)
        {
            if (jjtc000)
            {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else
            {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException)
            {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException)
            {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void Stmt() throws ParseException
    {/*@bgen(jjtree) Stmt */
        ASTStmt jjtn000 = new ASTStmt(JJTSTMT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        try
        {
            try
            {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case WHILE:
                    {
                        While();
                        break;
                    }
                    case IF:
                    {
                        If();
                        break;
                    }
                    default:
                        jj_la1[12] = jj_gen;
                        if (jj_2_6(3))
                        {
                            Assign();
                        } else
                        {
                            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                            {
                                case ID:
                                {
                                    Call();
                                    jj_consume_token(PVIRG);
                                    break;
                                }
                                default:
                                    jj_la1[13] = jj_gen;
                                    jj_consume_token(-1);
                                    throw new ParseException();
                            }
                        }
                }
            } catch (ParseException e)
            {
                System.out.println("Stmt Err:" + e.toString());
                Scanner.parse_error = true;
                Token t;
                do
                {
                    t = getNextToken();
                    if (t.kind == LCHAVETA)
                    {
                        ErrorBlock();
                        break;
                    }
                }
                while (t.kind != PVIRG && t.kind != RCHAVETA);
            }
        } catch (Throwable jjte000)
        {
            if (jjtc000)
            {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else
            {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException)
            {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException)
            {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void ErrorBlock() throws ParseException
    {/*@bgen(jjtree) ErrorBlock */
        ASTErrorBlock jjtn000 = new ASTErrorBlock(JJTERRORBLOCK);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        try
        {
            try
            {
                Stmtlst();
                jj_consume_token(RCHAVETA);
            } catch (ParseException e)
            {
                System.out.println("Stmt Err:" + e.toString());
                Scanner.parse_error = true;
                Token t;
                do
                {
                    t = getNextToken();
                }
                while (t.kind != RCHAVETA);
            }
        } catch (Throwable jjte000)
        {
            if (jjtc000)
            {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else
            {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException)
            {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException)
            {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void Assign() throws ParseException
    {/*@bgen(jjtree) Assign */
        ASTAssign jjtn000 = new ASTAssign(JJTASSIGN);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        try
        {
            try
            {
                Lhs();
                jj_consume_token(ASSIGN);
                Rhs();
                jj_consume_token(PVIRG);
            } catch (ParseException e)
            {
                System.out.println("Assign Err:" + e.toString());
                Scanner.parse_error = true;
                Token t;
                do
                {
                    t = getNextToken();
                }
                while (t.kind != PVIRG);
            }
        } catch (Throwable jjte000)
        {
            if (jjtc000)
            {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else
            {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException)
            {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException)
            {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void Lhs() throws ParseException
    {/*@bgen(jjtree) Lhs */
        ASTLhs jjtn000 = new ASTLhs(JJTLHS);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        try
        {
            if (jj_2_7(2))
            {
                ArrayAccess();
            } else
            {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case ID:
                    {
                        ScalarAccess();
                        break;
                    }
                    default:
                        jj_la1[14] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            }
        } catch (Throwable jjte000)
        {
            if (jjtc000)
            {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else
            {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException)
            {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException)
            {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void Rhs() throws ParseException
    {/*@bgen(jjtree) Rhs */
        ASTRhs jjtn000 = new ASTRhs(JJTRHS);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        Token op;
        try
        {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case ADDSUB_OP:
                case INTEGER:
                case ID:
                {
                    Term();
                    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                    {
                        case ADDSUB_OP:
                        case ARITH_OP:
                        case BITWISE_OP:
                        {
                            if (jj_2_8(3))
                            {
                                op = jj_consume_token(ARITH_OP);
                                jjtn000.op = op.image;
                            } else
                            {
                                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                                {
                                    case BITWISE_OP:
                                    {
                                        op = jj_consume_token(BITWISE_OP);
                                        jjtn000.op = op.image;
                                        break;
                                    }
                                    case ADDSUB_OP:
                                    {
                                        op = jj_consume_token(ADDSUB_OP);
                                        jjtn000.op = op.image;
                                        break;
                                    }
                                    default:
                                        jj_la1[15] = jj_gen;
                                        jj_consume_token(-1);
                                        throw new ParseException();
                                }
                            }
                            Term();
                            break;
                        }
                        default:
                            jj_la1[16] = jj_gen;
                            ;
                    }
                    break;
                }
                case 31:
                {
                    jj_consume_token(31);
                    ArraySize();
                    jj_consume_token(32);
                    break;
                }
                default:
                    jj_la1[17] = jj_gen;
                    jj_consume_token(-1);
                    throw new ParseException();
            }
        } catch (Throwable jjte000)
        {
            if (jjtc000)
            {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else
            {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException)
            {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException)
            {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void ArraySize() throws ParseException
    {/*@bgen(jjtree) ArraySize */
        ASTArraySize jjtn000 = new ASTArraySize(JJTARRAYSIZE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        Token t1;
        try
        {
            try
            {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case ID:
                    {
                        ScalarAccess();
                        break;
                    }
                    case INTEGER:
                    {
                        t1 = jj_consume_token(INTEGER);
                        jjtn000.sizeArray = Integer.parseInt(t1.image);
                        break;
                    }
                    default:
                        jj_la1[18] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            } catch (ParseException e)
            {
                System.out.println("ArraySize Err:" + e.toString());
                Scanner.parse_error = true;
            }
        } catch (Throwable jjte000)
        {
            if (jjtc000)
            {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else
            {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException)
            {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException)
            {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void Term() throws ParseException
    {/*@bgen(jjtree) Term */
        ASTTerm jjtn000 = new ASTTerm(JJTTERM);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        Token t1, t2;
        try
        {
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case ADDSUB_OP:
                {
                    t1 = jj_consume_token(ADDSUB_OP);
                    jjtn000.addSub_Op = t1.image;
                    break;
                }
                default:
                    jj_la1[19] = jj_gen;
                    ;
            }
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case INTEGER:
                {
                    t2 = jj_consume_token(INTEGER);
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                    if (jjtree.nodeCreated())
                    {
                        jjtreeCloseNodeScope(jjtn000);
                    }
                    jjtn000.termInt = Integer.parseInt(t2.image);
                    break;
                }
                default:
                    jj_la1[20] = jj_gen;
                    if (jj_2_9(3))
                    {
                        Call();
                    } else if (jj_2_10(3))
                    {
                        ArrayAccess();
                    } else
                    {
                        switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                        {
                            case ID:
                            {
                                ScalarAccess();
                                break;
                            }
                            default:
                                jj_la1[21] = jj_gen;
                                jj_consume_token(-1);
                                throw new ParseException();
                        }
                    }
            }
        } catch (Throwable jjte000)
        {
            if (jjtc000)
            {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else
            {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException)
            {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException)
            {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void Exprtest() throws ParseException
    {/*@bgen(jjtree) Exprtest */
        ASTExprtest jjtn000 = new ASTExprtest(JJTEXPRTEST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        Token t1;
        try
        {
            try
            {
                jj_consume_token(LPAR);
                Lhs();
                t1 = jj_consume_token(RELA_OP);
                jjtn000.rela_Op = t1.image;
                Rhs();
                jj_consume_token(RPAR);
            } catch (ParseException e)
            {
                System.out.println("Exprtest Err:" + e.toString());
                Scanner.parse_error = true;
                Token t;
                do
                {
                    t = getNextToken();
                }
                while (t.kind != RPAR);
            }
        } catch (Throwable jjte000)
        {
            if (jjtc000)
            {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else
            {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException)
            {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException)
            {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void While() throws ParseException
    {/*@bgen(jjtree) While */
        ASTWhile jjtn000 = new ASTWhile(JJTWHILE);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        try
        {
            try
            {
                jj_consume_token(WHILE);
                Exprtest();
                jj_consume_token(LCHAVETA);
            } catch (ParseException e)
            {
                System.out.println("while Err:" + e.toString());
                Scanner.parse_error = true;
                Token t;
                do
                {
                    t = getNextToken();
                }
                while (t.kind != LCHAVETA);
            }
            try
            {
                Stmtlst();
                jj_consume_token(RCHAVETA);
            } catch (ParseException e)
            {
                System.out.println("while Err:" + e.toString());
                Scanner.parse_error = true;
                Token t;
                do
                {
                    t = getNextToken();
                }
                while (t.kind != RCHAVETA);
            }
        } catch (Throwable jjte000)
        {
            if (jjtc000)
            {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else
            {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException)
            {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException)
            {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void If() throws ParseException
    {/*@bgen(jjtree) If */
        ASTIf jjtn000 = new ASTIf(JJTIF);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        try
        {
            jj_consume_token(IF);
            Exprtest();
            jj_consume_token(LCHAVETA);
            Stmtlst();
            jj_consume_token(RCHAVETA);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case ELSE:
                {
                    jj_consume_token(ELSE);
                    jj_consume_token(LCHAVETA);
                    Stmtlst();
                    jj_consume_token(RCHAVETA);
                    break;
                }
                default:
                    jj_la1[22] = jj_gen;
                    ;
            }
        } catch (Throwable jjte000)
        {
            if (jjtc000)
            {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else
            {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException)
            {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException)
            {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void Call() throws ParseException
    {/*@bgen(jjtree) Call */
        ASTCall jjtn000 = new ASTCall(JJTCALL);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        Token outerCalledID;
        Token innerCalledID = new Token();
        innerCalledID.image = null;
        try
        {
            outerCalledID = jj_consume_token(ID);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case 33:
                {
                    jj_consume_token(33);
                    innerCalledID = jj_consume_token(ID);
                    break;
                }
                default:
                    jj_la1[23] = jj_gen;
                    ;
            }
            jj_consume_token(LPAR);
            switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
            {
                case INTEGER:
                case ID:
                case STRING:
                {
                    ArgumentList();
                    break;
                }
                default:
                    jj_la1[24] = jj_gen;
                    ;
            }
            jj_consume_token(RPAR);
            jjtree.closeNodeScope(jjtn000, true);
            jjtc000 = false;
            if (jjtree.nodeCreated())
            {
                jjtreeCloseNodeScope(jjtn000);
            }
            jjtn000.outerCalledID = outerCalledID.image;
            jjtn000.innerCalledID = innerCalledID.image;
        } catch (Throwable jjte000)
        {
            if (jjtc000)
            {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else
            {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException)
            {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException)
            {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void ArgumentList() throws ParseException
    {/*@bgen(jjtree) ArgumentList */
        ASTArgumentList jjtn000 = new ASTArgumentList(JJTARGUMENTLIST);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        try
        {
            try
            {
                Argument();
                label_5:
                while (true)
                {
                    switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                    {
                        case VIRG:
                        {
                            ;
                            break;
                        }
                        default:
                            jj_la1[25] = jj_gen;
                            break label_5;
                    }
                    jj_consume_token(VIRG);
                    Argument();
                }
            } catch (ParseException e)
            {
                System.out.println("ArgumentList Err:" + e.toString());
                Scanner.parse_error = true;
            }
        } catch (Throwable jjte000)
        {
            if (jjtc000)
            {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else
            {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException)
            {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException)
            {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void Argument() throws ParseException
    {/*@bgen(jjtree) Argument */
        ASTArgument jjtn000 = new ASTArgument(JJTARGUMENT);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        Token t1;
        try
        {
            try
            {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case ID:
                    {
                        t1 = jj_consume_token(ID);
                        jjtn000.id = t1.image;
                        break;
                    }
                    case STRING:
                    {
                        t1 = jj_consume_token(STRING);
                        jjtn000.str = t1.image;
                        break;
                    }
                    case INTEGER:
                    {
                        t1 = jj_consume_token(INTEGER);
                        jjtn000.integer = Integer.parseInt(t1.image);
                        break;
                    }
                    default:
                        jj_la1[26] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            } catch (ParseException e)
            {
                System.out.println("Argument Err:" + e.toString());
                Scanner.parse_error = true;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void ArrayAccess() throws ParseException
    {/*@bgen(jjtree) ArrayAccess */
        ASTArrayAccess jjtn000 = new ASTArrayAccess(JJTARRAYACCESS);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        Token arrayID;
        try
        {
            try
            {
                arrayID = jj_consume_token(ID);
                jj_consume_token(31);
                Index();
                jj_consume_token(32);
                jjtn000.arrayID = arrayID.image;
            } catch (ParseException e)
            {
                System.out.println("ArrayAccess Err:" + e.toString());
                Scanner.parse_error = true;
            }
        } catch (Throwable jjte000)
        {
            if (jjtc000)
            {
                jjtree.clearNodeScope(jjtn000);
                jjtc000 = false;
            } else
            {
                jjtree.popNode();
            }
            if (jjte000 instanceof RuntimeException)
            {
                {
                    if (true) throw (RuntimeException) jjte000;
                }
            }
            if (jjte000 instanceof ParseException)
            {
                {
                    if (true) throw (ParseException) jjte000;
                }
            }
            {
                if (true) throw (Error) jjte000;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void ScalarAccess() throws ParseException
    {/*@bgen(jjtree) ScalarAccess */
        ASTScalarAccess jjtn000 = new ASTScalarAccess(JJTSCALARACCESS);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        Token id, size;
        try
        {
            try
            {
                id = jj_consume_token(ID);
                jjtn000.id = id.image;
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case 33:
                    {
                        jj_consume_token(33);
                        size = jj_consume_token(SIZE);
                        jjtn000.size = size.image;
                        break;
                    }
                    default:
                        jj_la1[27] = jj_gen;
                        ;
                }
            } catch (ParseException e)
            {
                System.out.println("ScalarAccess Err:" + e.toString());
                Scanner.parse_error = true;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static final public void Index() throws ParseException
    {/*@bgen(jjtree) Index */
        ASTIndex jjtn000 = new ASTIndex(JJTINDEX);
        boolean jjtc000 = true;
        jjtree.openNodeScope(jjtn000);
        jjtreeOpenNodeScope(jjtn000);
        Token t1;
        try
        {
            try
            {
                switch ((jj_ntk == -1) ? jj_ntk_f() : jj_ntk)
                {
                    case ID:
                    {
                        t1 = jj_consume_token(ID);
                        jjtn000.id = t1.image;
                        break;
                    }
                    case INTEGER:
                    {
                        t1 = jj_consume_token(INTEGER);
                        jjtn000.index = Integer.parseInt(t1.image);
                        break;
                    }
                    default:
                        jj_la1[28] = jj_gen;
                        jj_consume_token(-1);
                        throw new ParseException();
                }
            } catch (ParseException e)
            {
                System.out.println("Index Err:" + e.toString());
                Scanner.parse_error = true;
            }
        } finally
        {
            if (jjtc000)
            {
                jjtree.closeNodeScope(jjtn000, true);
                if (jjtree.nodeCreated())
                {
                    jjtreeCloseNodeScope(jjtn000);
                }
            }
        }
    }

    static private boolean jj_2_1(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_1();
        } catch (LookaheadSuccess ls)
        {
            return true;
        } finally
        {
            jj_save(0, xla);
        }
    }

    static private boolean jj_2_2(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_2();
        } catch (LookaheadSuccess ls)
        {
            return true;
        } finally
        {
            jj_save(1, xla);
        }
    }

    static private boolean jj_2_3(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_3();
        } catch (LookaheadSuccess ls)
        {
            return true;
        } finally
        {
            jj_save(2, xla);
        }
    }

    static private boolean jj_2_4(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_4();
        } catch (LookaheadSuccess ls)
        {
            return true;
        } finally
        {
            jj_save(3, xla);
        }
    }

    static private boolean jj_2_5(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_5();
        } catch (LookaheadSuccess ls)
        {
            return true;
        } finally
        {
            jj_save(4, xla);
        }
    }

    static private boolean jj_2_6(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_6();
        } catch (LookaheadSuccess ls)
        {
            return true;
        } finally
        {
            jj_save(5, xla);
        }
    }

    static private boolean jj_2_7(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_7();
        } catch (LookaheadSuccess ls)
        {
            return true;
        } finally
        {
            jj_save(6, xla);
        }
    }

    static private boolean jj_2_8(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_8();
        } catch (LookaheadSuccess ls)
        {
            return true;
        } finally
        {
            jj_save(7, xla);
        }
    }

    static private boolean jj_2_9(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_9();
        } catch (LookaheadSuccess ls)
        {
            return true;
        } finally
        {
            jj_save(8, xla);
        }
    }

    static private boolean jj_2_10(int xla)
    {
        jj_la = xla;
        jj_lastpos = jj_scanpos = token;
        try
        {
            return !jj_3_10();
        } catch (LookaheadSuccess ls)
        {
            return true;
        } finally
        {
            jj_save(9, xla);
        }
    }

    static private boolean jj_3R_9()
    {
        if (jj_scan_token(ID)) return true;
        if (jj_scan_token(31)) return true;
        if (jj_3R_16()) return true;
        return false;
    }

    static private boolean jj_3_8()
    {
        if (jj_scan_token(ARITH_OP)) return true;
        return false;
    }

    static private boolean jj_3R_13()
    {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_18())
        {
            jj_scanpos = xsp;
            if (jj_3R_19()) return true;
        }
        return false;
    }

    static private boolean jj_3R_18()
    {
        if (jj_3R_24()) return true;
        return false;
    }

    static private boolean jj_3R_32()
    {
        if (jj_scan_token(INTEGER)) return true;
        return false;
    }

    static private boolean jj_3R_17()
    {
        if (jj_3R_23()) return true;
        return false;
    }

    static private boolean jj_3R_31()
    {
        if (jj_scan_token(STRING)) return true;
        return false;
    }

    static private boolean jj_3_7()
    {
        if (jj_3R_9()) return true;
        return false;
    }

    static private boolean jj_3R_30()
    {
        if (jj_scan_token(ID)) return true;
        return false;
    }

    static private boolean jj_3R_12()
    {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_7())
        {
            jj_scanpos = xsp;
            if (jj_3R_17()) return true;
        }
        return false;
    }

    static private boolean jj_3R_25()
    {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_30())
        {
            jj_scanpos = xsp;
            if (jj_3R_31())
            {
                jj_scanpos = xsp;
                if (jj_3R_32()) return true;
            }
        }
        return false;
    }

    static private boolean jj_3R_14()
    {
        if (jj_scan_token(33)) return true;
        if (jj_scan_token(ID)) return true;
        return false;
    }

    static private boolean jj_3R_7()
    {
        if (jj_3R_11()) return true;
        return false;
    }

    static private boolean jj_3R_11()
    {
        if (jj_scan_token(ID)) return true;
        return false;
    }

    static private boolean jj_3_2()
    {
        if (jj_3R_6()) return true;
        return false;
    }

    static private boolean jj_3_3()
    {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3_2())
        {
            jj_scanpos = xsp;
            if (jj_3R_7()) return true;
        }
        if (jj_scan_token(ASSIGN)) return true;
        return false;
    }

    static private boolean jj_3R_29()
    {
        if (jj_3R_23()) return true;
        return false;
    }

    static private boolean jj_3R_8()
    {
        if (jj_3R_12()) return true;
        if (jj_scan_token(ASSIGN)) return true;
        if (jj_3R_13()) return true;
        return false;
    }

    static private boolean jj_3_10()
    {
        if (jj_3R_9()) return true;
        return false;
    }

    static private boolean jj_3R_20()
    {
        if (jj_3R_25()) return true;
        return false;
    }

    static private boolean jj_3R_22()
    {
        if (jj_scan_token(INTEGER)) return true;
        return false;
    }

    static private boolean jj_3_9()
    {
        if (jj_3R_10()) return true;
        return false;
    }

    static private boolean jj_3R_21()
    {
        if (jj_scan_token(ID)) return true;
        return false;
    }

    static private boolean jj_3R_28()
    {
        if (jj_scan_token(INTEGER)) return true;
        return false;
    }

    static private boolean jj_3R_16()
    {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_21())
        {
            jj_scanpos = xsp;
            if (jj_3R_22()) return true;
        }
        return false;
    }

    static private boolean jj_3R_15()
    {
        if (jj_3R_20()) return true;
        return false;
    }

    static private boolean jj_3R_6()
    {
        if (jj_scan_token(ID)) return true;
        if (jj_scan_token(31)) return true;
        return false;
    }

    static private boolean jj_3R_27()
    {
        if (jj_scan_token(ADDSUB_OP)) return true;
        return false;
    }

    static private boolean jj_3R_24()
    {
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_27()) jj_scanpos = xsp;
        xsp = jj_scanpos;
        if (jj_3R_28())
        {
            jj_scanpos = xsp;
            if (jj_3_9())
            {
                jj_scanpos = xsp;
                if (jj_3_10())
                {
                    jj_scanpos = xsp;
                    if (jj_3R_29()) return true;
                }
            }
        }
        return false;
    }

    static private boolean jj_3R_10()
    {
        if (jj_scan_token(ID)) return true;
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_14()) jj_scanpos = xsp;
        if (jj_scan_token(LPAR)) return true;
        xsp = jj_scanpos;
        if (jj_3R_15()) jj_scanpos = xsp;
        if (jj_scan_token(RPAR)) return true;
        return false;
    }

    static private boolean jj_3_5()
    {
        if (jj_3R_6()) return true;
        return false;
    }

    static private boolean jj_3R_26()
    {
        if (jj_scan_token(33)) return true;
        if (jj_scan_token(SIZE)) return true;
        return false;
    }

    static private boolean jj_3_4()
    {
        if (jj_3R_6()) return true;
        return false;
    }

    static private boolean jj_3R_23()
    {
        if (jj_scan_token(ID)) return true;
        Token xsp;
        xsp = jj_scanpos;
        if (jj_3R_26()) jj_scanpos = xsp;
        return false;
    }

    static private boolean jj_3_1()
    {
        if (jj_3R_6()) return true;
        return false;
    }

    static private boolean jj_3R_19()
    {
        if (jj_scan_token(31)) return true;
        return false;
    }

    static private boolean jj_3_6()
    {
        if (jj_3R_8()) return true;
        return false;
    }

    static private boolean jj_initialized_once = false;
    /**
     * Generated Token Manager.
     */
    static public ScannerTokenManager token_source;
    static SimpleCharStream jj_input_stream;
    /**
     * Current token.
     */
    static public Token token;
    /**
     * Next token.
     */
    static public Token jj_nt;
    static private int jj_ntk;
    static private Token jj_scanpos, jj_lastpos;
    static private int jj_la;
    static private int jj_gen;
    static final private int[] jj_la1 = new int[29];
    static private int[] jj_la1_0;
    static private int[] jj_la1_1;

    static
    {
        jj_la1_init_0();
        jj_la1_init_1();
    }

    private static void jj_la1_init_0()
    {
        jj_la1_0 = new int[]{0x8000000, 0x800000, 0x8000000, 0x100, 0x84000100, 0x8000, 0x8000000, 0x8000000, 0x8000000, 0x8000000, 0x80000, 0x8000000, 0x3000, 0x8000000, 0x8000000, 0x500, 0x700, 0x8c000100, 0xc000000, 0x100, 0x4000000, 0x8000000, 0x4000, 0x0, 0x4c000000, 0x80000, 0x4c000000, 0x0, 0xc000000,};
    }

    private static void jj_la1_init_1()
    {
        jj_la1_1 = new int[]{0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x2, 0x0, 0x0, 0x0, 0x2, 0x0,};
    }

    static final private JJCalls[] jj_2_rtns = new JJCalls[10];
    static private boolean jj_rescan = false;
    static private int jj_gc = 0;

    /**
     * Constructor with InputStream.
     */
    public Scanner(java.io.InputStream stream)
    {
        this(stream, null);
    }

    /**
     * Constructor with InputStream and supplied encoding
     */
    public Scanner(java.io.InputStream stream, String encoding)
    {
        if (jj_initialized_once)
        {
            System.out.println("ERROR: Second call to constructor of static parser.  ");
            System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
            System.out.println("       during parser generation.");
            throw new Error();
        }
        jj_initialized_once = true;
        try
        {
            jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e)
        {
            throw new RuntimeException(e);
        }
        token_source = new ScannerTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 29; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Reinitialise.
     */
    static public void ReInit(java.io.InputStream stream)
    {
        ReInit(stream, null);
    }

    /**
     * Reinitialise.
     */
    static public void ReInit(java.io.InputStream stream, String encoding)
    {
        try
        {
            jj_input_stream.ReInit(stream, encoding, 1, 1);
        } catch (java.io.UnsupportedEncodingException e)
        {
            throw new RuntimeException(e);
        }
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jjtree.reset();
        jj_gen = 0;
        for (int i = 0; i < 29; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Constructor.
     */
    public Scanner(java.io.Reader stream)
    {
        if (jj_initialized_once)
        {
            System.out.println("ERROR: Second call to constructor of static parser. ");
            System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
            System.out.println("       during parser generation.");
            throw new Error();
        }
        jj_initialized_once = true;
        jj_input_stream = new SimpleCharStream(stream, 1, 1);
        token_source = new ScannerTokenManager(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 29; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Reinitialise.
     */
    static public void ReInit(java.io.Reader stream)
    {
        jj_input_stream.ReInit(stream, 1, 1);
        token_source.ReInit(jj_input_stream);
        token = new Token();
        jj_ntk = -1;
        jjtree.reset();
        jj_gen = 0;
        for (int i = 0; i < 29; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Constructor with generated Token Manager.
     */
    public Scanner(ScannerTokenManager tm)
    {
        if (jj_initialized_once)
        {
            System.out.println("ERROR: Second call to constructor of static parser. ");
            System.out.println("       You must either use ReInit() or set the JavaCC option STATIC to false");
            System.out.println("       during parser generation.");
            throw new Error();
        }
        jj_initialized_once = true;
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jj_gen = 0;
        for (int i = 0; i < 29; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    /**
     * Reinitialise.
     */
    public void ReInit(ScannerTokenManager tm)
    {
        token_source = tm;
        token = new Token();
        jj_ntk = -1;
        jjtree.reset();
        jj_gen = 0;
        for (int i = 0; i < 29; i++) jj_la1[i] = -1;
        for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
    }

    static private Token jj_consume_token(int kind) throws ParseException
    {
        Token oldToken;
        if ((oldToken = token).next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        if (token.kind == kind)
        {
            jj_gen++;
            if (++jj_gc > 100)
            {
                jj_gc = 0;
                for (int i = 0; i < jj_2_rtns.length; i++)
                {
                    JJCalls c = jj_2_rtns[i];
                    while (c != null)
                    {
                        if (c.gen < jj_gen) c.first = null;
                        c = c.next;
                    }
                }
            }
            return token;
        }
        token = oldToken;
        jj_kind = kind;
        throw generateParseException();
    }

    @SuppressWarnings("serial")
    static private final class LookaheadSuccess extends java.lang.Error
    {
    }

    static final private LookaheadSuccess jj_ls = new LookaheadSuccess();

    static private boolean jj_scan_token(int kind)
    {
        if (jj_scanpos == jj_lastpos)
        {
            jj_la--;
            if (jj_scanpos.next == null)
            {
                jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
            } else
            {
                jj_lastpos = jj_scanpos = jj_scanpos.next;
            }
        } else
        {
            jj_scanpos = jj_scanpos.next;
        }
        if (jj_rescan)
        {
            int i = 0;
            Token tok = token;
            while (tok != null && tok != jj_scanpos)
            {
                i++;
                tok = tok.next;
            }
            if (tok != null) jj_add_error_token(kind, i);
        }
        if (jj_scanpos.kind != kind) return true;
        if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
        return false;
    }


    /**
     * Get the next Token.
     */
    static final public Token getNextToken()
    {
        if (token.next != null) token = token.next;
        else token = token.next = token_source.getNextToken();
        jj_ntk = -1;
        jj_gen++;
        return token;
    }

    /**
     * Get the specific Token.
     */
    static final public Token getToken(int index)
    {
        Token t = token;
        for (int i = 0; i < index; i++)
        {
            if (t.next != null) t = t.next;
            else t = t.next = token_source.getNextToken();
        }
        return t;
    }

    static private int jj_ntk_f()
    {
        if ((jj_nt = token.next) == null)
            return (jj_ntk = (token.next = token_source.getNextToken()).kind);
        else
            return (jj_ntk = jj_nt.kind);
    }

    static private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
    static private int[] jj_expentry;
    static private int jj_kind = -1;
    static private int[] jj_lasttokens = new int[100];
    static private int jj_endpos;

    static private void jj_add_error_token(int kind, int pos)
    {
        if (pos >= 100) return;
        if (pos == jj_endpos + 1)
        {
            jj_lasttokens[jj_endpos++] = kind;
        } else if (jj_endpos != 0)
        {
            jj_expentry = new int[jj_endpos];
            for (int i = 0; i < jj_endpos; i++)
            {
                jj_expentry[i] = jj_lasttokens[i];
            }
            jj_entries_loop:
            for (java.util.Iterator<?> it = jj_expentries.iterator(); it.hasNext(); )
            {
                int[] oldentry = (int[]) (it.next());
                if (oldentry.length == jj_expentry.length)
                {
                    for (int i = 0; i < jj_expentry.length; i++)
                    {
                        if (oldentry[i] != jj_expentry[i])
                        {
                            continue jj_entries_loop;
                        }
                    }
                    jj_expentries.add(jj_expentry);
                    break jj_entries_loop;
                }
            }
            if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
        }
    }

    /**
     * Generate ParseException.
     */
    static public ParseException generateParseException()
    {
        jj_expentries.clear();
        boolean[] la1tokens = new boolean[34];
        if (jj_kind >= 0)
        {
            la1tokens[jj_kind] = true;
            jj_kind = -1;
        }
        for (int i = 0; i < 29; i++)
        {
            if (jj_la1[i] == jj_gen)
            {
                for (int j = 0; j < 32; j++)
                {
                    if ((jj_la1_0[i] & (1 << j)) != 0)
                    {
                        la1tokens[j] = true;
                    }
                    if ((jj_la1_1[i] & (1 << j)) != 0)
                    {
                        la1tokens[32 + j] = true;
                    }
                }
            }
        }
        for (int i = 0; i < 34; i++)
        {
            if (la1tokens[i])
            {
                jj_expentry = new int[1];
                jj_expentry[0] = i;
                jj_expentries.add(jj_expentry);
            }
        }
        jj_endpos = 0;
        jj_rescan_token();
        jj_add_error_token(0, 0);
        int[][] exptokseq = new int[jj_expentries.size()][];
        for (int i = 0; i < jj_expentries.size(); i++)
        {
            exptokseq[i] = jj_expentries.get(i);
        }
        return new ParseException(token, exptokseq, tokenImage);
    }

    /**
     * Enable tracing.
     */
    static final public void enable_tracing()
    {
    }

    /**
     * Disable tracing.
     */
    static final public void disable_tracing()
    {
    }

    static private void jj_rescan_token()
    {
        jj_rescan = true;
        for (int i = 0; i < 10; i++)
        {
            try
            {
                JJCalls p = jj_2_rtns[i];
                do
                {
                    if (p.gen > jj_gen)
                    {
                        jj_la = p.arg;
                        jj_lastpos = jj_scanpos = p.first;
                        switch (i)
                        {
                            case 0:
                                jj_3_1();
                                break;
                            case 1:
                                jj_3_2();
                                break;
                            case 2:
                                jj_3_3();
                                break;
                            case 3:
                                jj_3_4();
                                break;
                            case 4:
                                jj_3_5();
                                break;
                            case 5:
                                jj_3_6();
                                break;
                            case 6:
                                jj_3_7();
                                break;
                            case 7:
                                jj_3_8();
                                break;
                            case 8:
                                jj_3_9();
                                break;
                            case 9:
                                jj_3_10();
                                break;
                        }
                    }
                    p = p.next;
                } while (p != null);
            } catch (LookaheadSuccess ls)
            {
            }
        }
        jj_rescan = false;
    }

    static private void jj_save(int index, int xla)
    {
        JJCalls p = jj_2_rtns[index];
        while (p.gen > jj_gen)
        {
            if (p.next == null)
            {
                p = p.next = new JJCalls();
                break;
            }
            p = p.next;
        }
        p.gen = jj_gen + xla - jj_la;
        p.first = token;
        p.arg = xla;
    }

    static final class JJCalls
    {
        int gen;
        Token first;
        int arg;
        JJCalls next;
    }

}
