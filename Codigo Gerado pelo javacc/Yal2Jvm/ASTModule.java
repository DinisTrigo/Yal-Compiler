package Yal2Jvm;

import Yal2Jvm.CodeGeneration.IR.ControlFlowGraph;
import Yal2Jvm.CodeGeneration.IR.IRContainer;

/* Generated By:JJTree: Do not edit this line. Yal2Jvm.ASTModule.java Version 4.3 */
 /* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
/**
 * Module expression generated by JJTree.
 * This node stores the module name.
 * ASTModule overrides the dump, fillStFirstPass and fillIRFirstPass methods from the SimpleNode class so it can introduce special behaviors for each.  
 */
public class ASTModule extends SimpleNode
{
    /**
     * The id/name of the module.
     */
    public String moduleName = "";
    /**
     * The control flow graph used to build the IR.
     */
    public ControlFlowGraph cfg;
    /**
     * Constructor of the non-terminal expression 'Module'.
     * @param id ID of the node.
     */
    public ASTModule(int id)
    {
        super(id);
    }
    /**
     * Constructor of the non-terminal expression 'Module'.
     * @param p Scanner object.
     * @param id ID of the node.
     */
    public ASTModule(Scanner p, int id)
    {
        super(p, id);
    }

    /**
     * Displays information about this node. Correctly formats the information for more user-friendly reading on the console.
     * The method is overridden in the derived classes whenever special behaviour is necessary.
     * @param prefix The prefix (one or more spaces) to correctly format the information.
     */
    public void dump(String prefix)
    {
        System.out.println(toString(prefix));
        System.out.println(prefix + "Yal2Jvm.Module Name:" + moduleName);
        if (children != null)
        {
            for (int i = 0; i < children.length; ++i)
            {
                SimpleNode n = (SimpleNode) children[i];
                if (n != null)
                {
                    n.dump(prefix + " ");
                }
            }
        }
    }

    /**
     * This method is called recursively to go through the entire AST to fill the symbol table.
     * It is Overridden by this derived classes because special behaviour is needed. That special behaviour is implemented by the function because there is no need for specific class since it is only two lines of code.
     * It is placed in the AST because it needs to go through it. The code to perform the actual filling and necessary semantic analysis is placed in different classes, respecting the single responsibility principle.
     * On the first pass, only function definitions are filled in the symbol table. Function bodies will be filled in the second pass.
     * @param st An Object that represents the symbol table to be filled.
     */
    @Override
    public void fillStFirstPass(ST st)
    {
        ((ModuleST) st).setModuleName(moduleName);
        super.fillStFirstPass(st);
    }

    /**
     * This method is called recursively to go through the entire AST to fill the intermediate representation (IR).
     * It is Overridden by this derived classes because special behaviour is needed. That special behaviour is implemented by the function because there is no need for specific class since it is only two lines of code.
     * It is placed in the AST because it needs to go through it. The code to perform the actual filling is placed in different classes, respecting the single responsibility principle.
     * On the first pass, only function definitions are filled in the intermediate representation. Function bodies will be filled in the second pass.
     * @param st An Object that represents the already filled symbol table.
     * @param irContainer A class representing the intermediate representation to be filled.
     */
    public void fillIRFirstPass(ST st, IRContainer irContainer)
    {
        irContainer = new ControlFlowGraph(moduleName);
        cfg = (ControlFlowGraph) irContainer;
        super.fillIRFirstPass(st, irContainer);
    }
}
/*
 * JavaCC - OriginalChecksum=70bbecbc94f886088d925551ab5edabf (do not edit this
 * line)
 */
