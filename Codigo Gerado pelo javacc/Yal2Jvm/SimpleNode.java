package Yal2Jvm;

import Yal2Jvm.CodeGeneration.IR.BasicBlock;
import Yal2Jvm.CodeGeneration.IR.IRContainer;

import java.util.HashSet;

/* Generated By:JJTree: Do not edit this line. Yal2Jvm.SimpleNode.java Version 4.3 */
 /* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
/**
 * Class which extends all AST classes.
 * Has all the default methods of the AST classes.
 */
public class SimpleNode implements Node
{

	/**
	 * The parent of this node.
	 */
    protected Node parent;
    /**
     * All the child nodes of this node.
     */
    protected Node[] children;
    /**
     * The ID of this node.
     */
    protected int id;
    /**
     * The value.
     */
    protected Object value;
    /**
     * Reference to the Scanner. 
     */
    protected Scanner parser;
    /**
     * The blocks of this node.
     */
    protected BasicBlock[] blocks;
    
    /**
     * Constructor of SimpleNode.
     * @param id ID of the node.
     */
    public SimpleNode(int i)
    {
        id = i;
    }

    /**
     * Constructor of SimpleNode.
     * @param p Scanner object.
     * @param id ID of the node.
     */
    public SimpleNode(Scanner p, int i)
    {
        this(i);
        parser = p;
    }

    public void jjtOpen()
    {
    }

    public void jjtClose()
    {
    }

    public void jjtSetParent(Node n)
    {
        parent = n;
    }

    public Node jjtGetParent()
    {
        return parent;
    }

    public void jjtAddChild(Node n, int i)
    {
        if (children == null)
        {
            children = new Node[i + 1];
        } else if (i >= children.length)
        {
            Node c[] = new Node[i + 1];
            System.arraycopy(children, 0, c, 0, children.length);
            children = c;
        }
        children[i] = n;
    }

    public Node jjtGetChild(int i)
    {
        return children[i];
    }

    public int jjtGetNumChildren()
    {
        return (children == null) ? 0 : children.length;
    }

    public void jjtSetValue(Object value)
    {
        this.value = value;
    }

    public Object jjtGetValue()
    {
        return value;
    }

    /* You can override these two methods in subclasses of Yal2Jvm.SimpleNode to
     customize the way the node appears when the tree is dumped.  If
     your output uses more than one line you should override
     toString(String), otherwise overriding toString() is probably all
     you need to do. */
    public String toString()
    {
        return ScannerTreeConstants.jjtNodeName[id];
    }

    public String toString(String prefix)
    {
        return prefix + toString();
    }

    public int getId()
    {
        return 0;
    }

    public Node[] getChildren()
    {
        return children;
    }
    /* Override this method if you want to customize how the node dumps
     out its children. */

    private int line;

    public int getLine()
    {
        return line;
    }

    public void setLine(int line)
    {
        this.line = line;
    }

    public BasicBlock[] getBlocks()
    {
        return blocks;
    }

    public void setBlocks(BasicBlock[] blocks)
    {
        this.blocks = blocks;
    }

    public Node getParent()
    {
        return parent;
    }


    /**
     * Displays information about this node. Correctly formats the information for more user-friendly reading on the console.
     * The method is overridden in the derived classes whenever special behaviour is necessary.
     * @param prefix The prefix (one or more spaces) to correctly format the information.
     */
    public void dump(String prefix)
    {
        System.out.println(toString(prefix));
        if (children != null)
        {
            for (int i = 0; i < children.length; ++i)
            {
                SimpleNode n = (SimpleNode) children[i];
                if (n != null)
                {
                    n.dump(prefix + " ");
                }
            }
        }
    }

    /**
     * This method is called recursively to go through the entire AST to fill the symbol table.
     * It is Overridden by the derived classes when special behaviour is needed.
     * It is placed in the AST because it needs to go through it. The code to perform the actual filling and necessary semantic analysis is placed in different classes, respecting the single responsibility principle.
     * On the first pass, only function definitions are filled in the symbol table. Function bodies will be filled in the second pass.
     * @param st An Object that represents the symbol table to be filled.
     */
    public void fillStFirstPass(ST st)
    {
        if (children == null)
            return;
        for (int i = 0; i < children.length; i++)
            ((SimpleNode) children[i]).fillStFirstPass(st);
    }

    /**
     * This method is called recursively to go through the entire AST to fill the symbol table.
     * It is Overridden by the derived classes when special behaviour is needed.
     * It is placed in the AST because it needs to go through it. The code to perform the actual filling and necessary semantic analysis is placed in different classes, respecting the single responsibility principle.
     * On the second pass, function bodies are filled in the symbol table.
     * @param st An Object that represents the symbol table to be filled.
     */
    public void fillStSecondPass(ST st)
    {
        if (children == null)
            return;
        for (int i = 0; i < children.length; i++)
            ((SimpleNode) children[i]).fillStSecondPass(st);
    }

    /**
     * This method is called recursively to go through the entire AST verify the operator syntax.
     * It is Overridden by the derived classes when special behaviour is needed.
     * It is placed in the AST because it needs to go through it. The code to perform the actual verification of the operator syntax is placed in different classes, respecting the single responsibility principle.
     * @param st An Object that represents the already filled symbol table.
     * @param operatorHasToBeInt A boolean indicating weather the next operator found has to be an int or not.
     */
    public void verifyOperatorSyntax(ST st, boolean operatorHasToBeInt)
    {
        if (children == null)
            return;
        for (int i = 0; i < children.length; i++)
            ((SimpleNode) children[i]).verifyOperatorSyntax(st, operatorHasToBeInt);
    }

    /**
     * This method is called recursively to go through the entire AST verify the variable initialization.
     * It is Overridden by the derived classes when special behaviour is needed.
     * It is placed in the AST because it needs to go through it. The code to perform the actual verification of the variable initialization is placed in different classes, respecting the single responsibility principle.
     * @param initializedVariables A set containing the currently initialized variables (in the current node of the AST). As new variables get initialized, they are added to the set.
     * @param st An Object that represents the already filled symbol table.
     * @return The set of initialized variables after the current AST node (new variables could eventually have been added to the set it received as parameter if they actually for initialized in the current AST node).
     */
    public HashSet verifyInitialization(HashSet<String> initializedVariables, ST st)
    {
        if (children == null)
            return initializedVariables;
        for (int i = 0; i < children.length; i++)
            initializedVariables.addAll(((SimpleNode) children[i]).verifyInitialization(new HashSet<String>(initializedVariables), st));

        return initializedVariables;
    }

    /**
     * This method is called recursively to go through the entire AST to fill the intermediate representation (IR).
     * It is Overridden by the derived classes when special behaviour is needed.
     * It is placed in the AST because it needs to go through it. The code to perform the actual filling is placed in different classes, respecting the single responsibility principle.
     * On the first pass, only function definitions are filled in the intermediate representation. Function bodies will be filled in the second pass.
     * @param st An Object that represents the already filled symbol table.
     * @param irContainer A class representing the intermediate representation to be filled.
     */
    public void fillIRFirstPass(ST st, IRContainer irContainer)
    {
        if (children == null)
            return;
        for (int i = 0; i < children.length; i++)
            ((SimpleNode) children[i]).fillIRFirstPass(st, irContainer);
    }

    /**
     * This method is called recursively to go through the entire AST to fill the intermediate representation (IR).
     * It is Overridden by the derived classes when special behaviour is needed.
     * It is placed in the AST because it needs to go through it. The code to perform the actual filling is placed in different classes, respecting the single responsibility principle.
     * On the second pass, function bodies are filled in the intermediate representation.
     * @param st An Object that represents the already filled symbol table.
     * @param irContainer A class representing the intermediate representation to be filled.
     * @param currentBlock A class representing the current block on the IR of this SimpleNode. This is used to perform branching on certain conditions.
     */
    public void fillIRSecondPass(ST st, IRContainer irContainer, BasicBlock currentBlock)
    {
        if (children == null)
            return;
        for (int i = 0; i < children.length; i++)
            ((SimpleNode) children[i]).fillIRSecondPass(st, irContainer, currentBlock);
    }
}

/* JavaCC - OriginalChecksum=f6bf7edaebc61a0f72e9a050ea4edc26 (do not edit this line) */
