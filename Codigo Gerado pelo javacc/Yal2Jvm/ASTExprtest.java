package Yal2Jvm;

import Yal2Jvm.CodeGeneration.IR.BasicBlock;
import Yal2Jvm.CodeGeneration.IR.IRContainer;
import Yal2Jvm.CodeGeneration.IR.Method;
import Yal2Jvm.CodeGeneration.IR.Operand;
import Yal2Jvm.CodeGeneration.IRFilling.TermIRFiller;
import Yal2Jvm.SemanticAnalysis.STFilling.ExprtestSTFiller;

/* Generated By:JJTree: Do not edit this line. Yal2Jvm.ASTExprtest.java Version 4.3 */
 /* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
/**
 * Exprtest expression generated by JJTree.
 * This node stores the relation used to compare two variables.
 * ASTExprtest overrides the dump and fillStSecondPass methods from the SimpleNode class so it can introduce special behaviors for each. And it adds the functions getRelaopStr and getRhsOperand.
 */
public class ASTExprtest extends SimpleNode
{
    /**
     * The operand used in the conditional branch expression tests.
     */
    public String rela_Op;

    /**
     * Constructor of the non-terminal expression 'Exprtest'.
     * @param id ID of the node.
     */
    public ASTExprtest(int id)
    {
        super(id);
    }

    /**
     * Constructor of the non-terminal expression 'Exprtest'.
     * @param p Scanner object.
     * @param id ID of the node.
     */
    public ASTExprtest(Scanner p, int id)
    {
        super(p, id);
    }

    /**
     * Displays information about this node. Correctly formats the information for more user-friendly reading on the console.
     * The method is overridden in the derived classes whenever special behaviour is necessary.
     * @param prefix The prefix (one or more spaces) to correctly format the information.
     */
    public void dump(String prefix)
    {
        System.out.println(toString(prefix));
        if (children != null)
        {
            for (int i = 0; i < children.length; ++i)
            {
                SimpleNode n = (SimpleNode) children[i];
                if (n != null)
                {
                    n.dump(prefix + " ");
                }
                if (i == 0)
                    System.out.println(prefix + " Relation operand: " + rela_Op);
            }
        }
    }

    /**
     * This method is called recursively to go through the entire AST to fill the symbol table.
     * It is Overridden by this derived classes because special behaviour is needed. That special behaviour is implemented by the function fillStSecondPass on the class ExprtestSTFiller.
     * It is placed in the AST because it needs to go through it. The code to perform the actual filling and necessary semantic analysis is placed in different classes, respecting the single responsibility principle.
     * On the second pass, function bodies are filled in the symbol table.
     * @param st An Object that represents the symbol table to be filled.
     */
    @Override
    public void fillStSecondPass(ST st)
    {
        ExprtestSTFiller.fillStSecondPass(this, st);
    }

    public Operand getRhsOperand(ST st, IRContainer irContainer, BasicBlock currentBlock)
    {
        SimpleNode child = (SimpleNode) children[1];
        if (child.children[0] instanceof ASTTerm)
        {
            return TermIRFiller.getOperand(((ASTTerm) child.children[0]), st, (Method) irContainer, currentBlock);
        }
        else
            return null;

    }

    public String getRelaopStr(ST st, IRContainer irContainer)
    {
        return rela_Op;
    }
}
/*
 * JavaCC - OriginalChecksum=5be40f05ed2b7a722d19d9bd0e915b23 (do not edit this
 * line)
 */
