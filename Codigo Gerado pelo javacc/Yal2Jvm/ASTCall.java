package Yal2Jvm;

import Yal2Jvm.CodeGeneration.IR.*;
import Yal2Jvm.CodeGeneration.IRFilling.CallIRFiller;

import java.util.ArrayList;

/* Generated By:JJTree: Do not edit this line. Yal2Jvm.ASTCall.java Version 4.3 */
 /* JavaCCOptions:MULTI=true,NODE_USES_PARSER=false,VISITOR=false,TRACK_TOKENS=false,NODE_PREFIX=AST,NODE_EXTENDS=,NODE_FACTORY=,SUPPORT_CLASS_VISIBILITY_PUBLIC=true */
/**
 * Call expression generated by JJTree.
 * This node stores the name of the method being called in Yal, and stores the name of the module where the method resides if specified.
 * ASTCall overrides the dump and fillIRSecondPass, and adds a the function returnIsArray.
 */
public class ASTCall extends SimpleNode
{
    /**
     * The name of the package if innercalledID exists or the name of the function, otherwise.
     */
    public String outerCalledID;
    /**
     * The name of the function inside outercalledID package. Can be null if outercalledID is a function instead.
     */
    public String innerCalledID;

    /**
     * Constructor of the non-terminal expression 'Call'.
     * @param id ID of the node.
     */
    public ASTCall(int id)
    {
        super(id);
    }
    /**
     * Constructor of the non-terminal expression 'Call'.
     * @param p Scanner object.
     * @param id ID of the node.
     */
    public ASTCall(Scanner p, int id)
    {
        super(p, id);
    }

    /**
     * Displays information about this node. Correctly formats the information for more user-friendly reading on the console.
     * The method is overridden in the derived classes whenever special behaviour is necessary.
     * @param prefix The prefix (one or more spaces) to correctly format the information.
     */
    public void dump(String prefix)
    {
        System.out.println(toString(prefix));
        System.out.println(prefix + " Outer Id: " + outerCalledID);
        if (innerCalledID != null)
            System.out.println(prefix + " Inner Id: " + innerCalledID);
        if (children != null)
        {
            for (int i = 0; i < children.length; ++i)
            {
                SimpleNode n = (SimpleNode) children[i];
                if (n != null)
                {
                    n.dump(prefix + " ");
                }
            }
        }
    }

    /**
     * Returns a boolean value indicating weather the return of the function represented by this AST node is an array or not (int if not array).
     * @param st An Object that represents the already filled symbol table.
     * @return A boolean value indicating weather the return of the function represented by this AST node is an array or not (int if not array).
     * @throws ExternalModuleCall Thrown in case innerCalledID is not null, because it can't be a method from a module.
     */
    public Boolean returnIsArray(ST st) throws ExternalModuleCall
    {
        ModuleST globalSt = ((FunctionST) st).globalST;
        if (innerCalledID != null)
            throw new ExternalModuleCall();

        //checks that the function parameters match with the declaration
        FunctionST funct = globalSt.getFunctionST(outerCalledID);
        if (funct != null && children != null)
        {
            ASTArgumentList argList = null;
            if (children[0] instanceof ASTArgumentList)
                argList = (ASTArgumentList) children[0];
            else if (children.length > 1)
                argList = (ASTArgumentList) children[1];
            else
                return null;
            ArrayList<Boolean> args = new ArrayList();
            Node[] arguments = argList.children;
            for (int i = 0; i < arguments.length; ++i)
            {
                ASTArgument arg = ((ASTArgument) arguments[i]);
                if (arg.id != null)
                {
                    Boolean val = ((FunctionST) st).isVariableArray(arg.id);
                    if (val == null)
                    {
                        val = globalSt.isVariableArray(arg.id);
                        if (val == null)
                        {
                            System.out.println("Undeclared Varible:" + arg.id + " on line: " + getLine());
                            st.declareCodeHasSemanticErrors();
                            return null;
                        }
                    }
                    args.add(val);
                } else if (arg.str != null)
                {
                    args.add(false);
                } else if (arg.integer != null)
                {
                    args.add(false);
                }
            }

            ArrayList<Boolean> expectedArgs = funct.paramsTypes;
            if (args.size() != expectedArgs.size())
            {
                System.out.println("Incorrect number of arguments found" + " on line: " + getLine());
                st.declareCodeHasSemanticErrors();
                return null;
            }
            for (int i = 0; i < args.size(); ++i)
            {
                if (args.get(i) != expectedArgs.get(i))
                {
                    System.out.println("Incorrect Parameter Type Found:" + args.get(i) + " Expected:" + expectedArgs.get(i) + " on line: " + getLine());
                    st.declareCodeHasSemanticErrors();
                    return null;
                }
            }
        }
        //end the check
        return globalSt.getFunctionST(outerCalledID).returnIsArray;
    }

    /**
     * This method is called recursively to go through the entire AST to fill the intermediate representation (IR).
     * It is Overridden by this derived classes because special behaviour is needed. That special behaviour is implemented by the function fillIRSecondPass on the class CallIRFiller.
     * It is placed in the AST because it needs to go through it. The code to perform the actual filling is placed in different classes, respecting the single responsibility principle.
     * On the first pass, only function definitions are filled in the intermediate representation. Function bodies will be filled in the second pass.
     * @param st An Object that represents the already filled symbol table.
     * @param irContainer A class representing the intermediate representation to be filled.
     * @param currentBlock A class representing the current block on the IR of this AST node. This is used to perform branching on certain conditions.
     */
    public void fillIRSecondPass(ST st, IRContainer irContainer, BasicBlock currentBlock)
    {
        CallIRFiller.fillIRSecondPass(this, st, irContainer, currentBlock);
    }
}
/*
 * JavaCC - OriginalChecksum=1de5c7ed5e0068a943cb763561aa149e (do not edit this
 * line)
 */
